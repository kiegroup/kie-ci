@Library('jenkins-pipeline-shared-libraries')_
@Library('qe-library')

import com.cloudbees.hudson.plugins.folder.Folder

Map<String, String> buildResults = [:]

Map<String, String> imageBuildParams = [:]
Map<String, String> operatorBuildParams = [:]

String propertyFileUrl = "${CI_MESSAGE}"

TIMEOUT = 4

pipeline {
    options {
        timeout(time: TIMEOUT, unit: 'HOURS')
    }

    agent {
        label 'kie-rhel7 && !built-in'
    }

    environment {
        PRODUCT_NAME = PROD_COMPONENT.trim()
        VERSION = PROD_VERSION.trim()
    }

    stages {
        stage('Clean workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Ready CI MESSAGE') {
            steps {
                script {
                    if ( CI_MESSAGE == null || CI_MESSAGE == "" ) {
                        logConsole.info("CI_MESSAGE is null or empty. Taking property file url from job parameter. ")
                        propertyFileUrl="${PROPERTY_FILE_URL}"
                    } else {
                        logConsole.info("CI_MESSAGE is not null nor empty. Taking property file url from CI-message.")
                        propertyFileUrl="${CI_MESSAGE}"
                    }

                    if ( propertyFileUrl.isEmpty() || propertyFileUrl == "" ) {
                        error("No property files with artifacts provided. Setting stage result to \"FAILURE\"")
                    }

                    echo "URL of property file: $propertyFileUrl"

                    // TODO - maybe not needed as we will hnad over propertyFileUrl to jobs :)
                    def downloadedPropertiesFile = sh returnStdout: true, script: "wget -O- $propertyFileUrl"
                    // insert newline to avoid failure when there's none
                    downloadedPropertiesFile += "\n"

                    echo "Downloaded properties:\n$downloadedPropertiesFile"

                    testingUtils.loadEnvFromPropertiesFile("$propertyFileUrl")
                    
                }
                sh 'printenv'
            }

        }

        stage('Build nightly images') {
            steps {
                script {
                    //List<String> buildJobs = utils.sortByLength(dynamicStageUtils.getAllJobsNamesFromFolders(utils.toAbsolutePath("${PRODUCT_NAME.toLowerCase()}-images")))
                    List<String> buildJobs = utils.sortByLength(getAllJobsNamesFromFolders("OSBS/${PRODUCT_NAME.toLowerCase()}-images"))
                    //buildJobs.removeAll { it.containes("operator") } // we should probably not include operator build here
                    Map<String, Closure> sequences = getParallelStages(buildJobs, propertyFileUrl, buildResults)
                    parallel sequences

                    /* example...
                    // all jobs from toAbsolutePath("bamoe-images")
                    // all jobs from toAbsolutePath("rhpam-images")
                    parallel {
                        stage('Biuld BC') {
                        }
                        stage('Build KS') {
                        }
                        //...
                    }
                    */
                }
            }
        }

        stage('Build operator') {
            steps {
                script {
                    println "NOTHING TO DO YET"

                    // some jobs from toAbsolutePath("operators")
                    // jobs name looks lika "${PRODUCT_NAME.toLowerCase()}-ba-operator"
                    /*
                    List<String> buildJobs = utils.sortByLength(dynamicStageUtils.getAllJobsNamesFromFolders(utils.toAbsolutePath("operators")))
                    buildJobs.removeAll { !it.containes("${PRODUCT_NAME.toLowerCase()}-ba-operator") } // we want only build operator in this stage
                    Map<String, Closure> sequences = getParallelStages(buildJobs, propertyFileUrl, buildResults)
                    parallel sequences
                    */
                }
            }

        }

        stage('Build operator bundle') {
            //optional?
            steps {
                scripts {
                    println "NOTHING TO DO YET"
                }
            }

        }

        stage('Print build results') {
            steps {
                script {
                    testingUtils.printResults("OSBS ${PRODUCT_NAME} IMAGE BUILD results", buildResults)
                }
            }
        }

        stage('Collect image references') {
            when {
                expression {
                    return buildResults.every{ it.value.equals("SUCCESS") }
                }
            }
            steps {
                scripts {
                    // TODO 
                }
            }
        }

        stage ('Send UMB Message to QE.') {
            when {
                expression {
                    return buildResults.every{ it.value.equals("SUCCESS") }
                }
            }
            steps {
                script {
                    echo "Sending OCP ${PRODUCT_NAME} IMAGE BUILD UMB message to QE."

                    // String triggerTopic = "VirtualTopic.qe.ci.ba.${product}.${version}.${stream}.trigger"
                    def topic = "VirtualTopic.qe.ci.ba.${PRODUCT_NAME.toLowerCase()}-images.${VERSION}.nightly.trigger"
                    def eventType = "${PRODUCT_NAME.toLowerCase()}-images-${VERSION}-nightly-qe-trigger"
                    def messageBody = getMessageBody( // TODO
                        mavenRepositoryFileUrl, 
                        env.ALREADY_BUILT_PROJECTS,
                        ['serverlesslogic': PME_BUILD_VARIABLES['kogitoProductVersion'], 'serverlesslogic-rhba': PME_BUILD_VARIABLES['kogitoProductVersion'], 'drools': PME_BUILD_VARIABLES['droolsProductVersion'], 'platform.quarkus.bom': PME_BUILD_VARIABLES['quarkusPlatformVersion'].replaceAll("\\{\\{.*\\}\\}", PME_BUILD_VARIABLES['quarkusVersionCommunity']), 'quarkus.bom': PME_BUILD_VARIABLES['quarkusVersion'].replaceAll("\\{\\{.*\\}\\}", PME_BUILD_VARIABLES['quarkusVersionCommunity'])],
                        gitHashesToCollection(env.GIT_INFORMATION_HASHES)
                    )
                    echo "[INFO] Message Body: ${messageBody}"
                    echo "[INFO] Topic: ${topic}"
                    echo "[INFO] Event Type: ${eventType}"
                    /* send umb message skip for now
                    build job: env.SEND_UMB_MESSAGE_JOB_PATH, parameters: [
                            [$class: 'StringParameterValue', name: 'MESSAGE_BODY', value: messageBody],
                            [$class: 'StringParameterValue', name: 'TOPIC', value: topic],
                            [$class: 'StringParameterValue', name: 'EVENT_TYPE', value: eventType]
                    ]
                    */
                    echo '[SUCCESS] Message was successfully sent.'


                }
            }
        }
    }

    post {
        /* send emails skip for now
        failure {
            emailext body: 'OSBS ${PRODUCT_NAME} IMAGE BUILD ${PRODUCT_VERSION}:nightly-build #${BUILD_NUMBER} was: ' + "${currentBuild.currentResult}" +  '\n' +
                    'Please look here: ${BUILD_URL} \n',
                    subject: 'OSBS ${PRODUCT_NAME} IMAGE BUILD:nightly-build #${BUILD_NUMBER}: ' + "${currentBuild.currentResult}", to: 'bsig-cloud+ci@redhat.com'
        }
        unstable {
            emailext body: 'OSBS ${PRODUCT_NAME} IMAGE BUILD ${PRODUCT_VERSION}:nightly-build #${BUILD_NUMBER} was: ' + "${currentBuild.currentResult}" +  '\n' +
                    'Please look here: ${BUILD_URL} \n',
                    subject: 'OSBS ${PRODUCT_NAME} IMAGE BUILD:nightly-build #${BUILD_NUMBER}: ' + "${currentBuild.currentResult}", to: 'bsig-cloud+ci@redhat.com'
        }
        fixed {
            emailext body: 'OSBS ${PRODUCT_NAME} IMAGE BUILD ${PRODUCT_VERSION}:nightly-build #${BUILD_NUMBER} was: ' + "${currentBuild.currentResult}" +  '\n' +
                    'Please look here: ${BUILD_URL} \n',
                    subject: 'OSBS ${PRODUCT_NAME} IMAGE BUILD:nightly-build #${BUILD_NUMBER}: ' + "${currentBuild.currentResult}", to: 'bsig-cloud+ci@redhat.com'
        }*/
        cleanup {
            cleanWs()
        }
    }
}

/**
 * Dynamically generates pipeline stages based on the build jobs obtained in the previous step
 * @param buildJobs List containing all image building jobs
 * @param propertyFileUrl String url to properties file that can be download in builder job
 * @param buildResults Map to save build results to
 * @return Map that can be handed over to a <a href="https://www.jenkins.io/doc/book/pipeline/syntax/#parallel">'parallel'<a> pipeline section.
 */
Map<String, Closure> getParallelStages(List<String> buildJobs, String propertyFileUrl, Map<String, String> buildResults) {
    buildJobs.collectEntries {
        [(testingUtils.getShortJobName(it)): getSingleStagesSequence(it, propertyFileUrl, buildResults)]
    }
}

/**
 * Generate single sequence (branch of pipeline parallel section) of jobs
 * @param jobName Name of the build job
 * @param propertyFileUrl String url to properties file that can be download in builder job
 * @param buildResults Map to save build results to
 * @return Closure defining stages sequence to run within a pipeline
 */
Closure getSingleStagesSequence(String jobName, String propertyFileUrl, Map<String, String> buildResults) {
    return {
        stage(testingUtils.getShortJobName(jobName)) {
            logConsole.info("Running ${jobName} job")

            String buildResultString
            try {
                println "tmp log output instead of job run - simulation of ${jobName} build job"
                /* TODO tmp skip for now
                def jobRun = build job: "$jobName", parameters: [string(name: 'PROPERTY_FILE_URL', value: propertyFileUrl)], propagate: false, wait: true
                buildResultString = jobRun.getResult()
                */
                buildResultString = "temporary SKIPED for now"
            } catch (Throwable e) {
                logConsole.error("${e.getMessage()}")
                buildResultString = 'FAILURE'
            }
            buildResults.put(jobName, buildResultString)

            // we want stage to have same color as the actual baseline, but we don't want to fail whole pipeline (yet)
            catchError(buildResult: 'UNSTABLE', stageResult: buildResultString) {
                // so we need to do this little hack for all results worse than SUCCESS, other approaches
                // would either affect also pipeline result or would not change the stage color
                if (buildResultString != "SUCCESS") {
                    error("Job result was $buildResultString. Setting stage result to $buildResultString.")
                }
            }
        }
    }
}


// tmp added to avoid NonCPS from the dynamincStageUtils

List<String> getAllJobsNamesFromFolders(String... folderPaths) {
    if (folderPaths == null || (folderPaths.size() == 0)) {
        logConsole.error("folderPaths parameter cannot be empty.")
        return null
    }

    List<String> jobs = new ArrayList<String>()
    for (String folderPath : folderPaths) {
        if (utils.isNullOrEmpty(folderPath)) {
            logConsole.error("folderPath is null or empty")
            continue
        }
        def folder = Hudson.instance.getItemByFullName(folderPath, Folder.class)
        if (folder != null) {
            folder.getItems().each {
                if (it instanceof Folder) {
                    jobs.addAll(getAllJobsNamesFromFolders(it.getFullName()))
                } else {
                    jobs.add(it.getFullName())
                }
            }
        } else {
            println("\u001b[33m[WARN] '${folderPath}' item does not exist. Skipping\u001b[0m")
        }
    }
    return jobs
}


